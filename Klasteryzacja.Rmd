---
title: "Klasyfikacja nienadzorowana"
author: "Krzysztof Dyba"
output: html_document
date: 02.12.2022 r.
---

## Wczytanie danych

```{r message=FALSE}
# wczytanie pakietu
library("terra")
```

W pierwszym kroku musimy wylistować dane (rastry), które zamierzamy wczytać.
W tym celu możemy wykorzystać funkcję `list.files()`, która jako agrument przyjmuje
ścieżkę do folderu z plikami. Oprócz tego musimy wskazać jaki rodzaj plikóW chcemy
wczytać (`pattern = "\\.TIF$"`) oraz zwrócić ścieżki bezwzględne do plikóW.

```{r}
files = list.files("dane", pattern = "\\.TIF$", full.names = TRUE)
files
```

Kiedy utworzyliśmy już listę plikóW, możemy je wczytać przy pomocy
funkcji `rast()` z pakietu `{terra}` i następnie wyświetlić metadane.

```{r}
landsat = rast(files)
landsat # odwłoanie się do obiektu wyświetla metadane
```

Możemy również skrócić lub zmienić nazwy kanałów spektralnych. Przed tą operacją
należy się upewnić czy kanały zostały wczytane w prawidłowej kolejności.

```{r}
names(landsat) # nazwy oryginalne
names(landsat) = paste0("B", 1:7) # skrócenie nazw
names(landsat) # nowe nazwy

# zamiana nazw
# names(landsat) = c("Ultra Blue", "Blue", "Green", "Red", "NIR", "SWIR1", "SWIR2")
```

Wczytanie danych wektorowych odybywa się w analogiczny sposób za pomocą funkcji
`vect()`.

```{r}
poly = vect("dane/powiat_sremski.gpkg")
poly
```

Teraz możemy przygotować prostą wizualizację jednego kanału oraz poligonu.

```{r}
plot(landsat[[1]])
plot(poly, add = TRUE)
```

## Operacje na rastrach

Zasięg naszego obszaru analizy ograniczony jest do powiatu śremskiego, natomiast
scena satelitarna ma o wiele więszy zasięg. W takiej sytuacji możemy dociąć rastry,
dzięki czemu przetwarzanie będzie szybsze, a finalna mapa zajmniej mniej miejsca
na dysku. Do docinania rastrów służy funkcja `crop()` i jako argumenty musimy podać
raster oraz wektor.

```{r}
landsat = crop(landsat, poly)
plot(landsat[[1]])
plot(poly, add = TRUE)
```

Obszar rastra zmniejszył się. Jednak możemy zauważyć, że poza poligonem wartości
nie zostały usunięte. Wynika to z faktu, że obraz zawsze docinany jest do obwiedni
(*bounding box*), a wartości poza obiektem/poligonem w rzeczywistości są maskowane
(tj. są oznaczane jako brakujące wartości). Aby zamaskować piksele poza poligonem
należy użyć funkcji `mask()`.

```{r}
landsat = mask(landsat, poly)
plot(landsat[[1]])
plot(poly, add = TRUE)
```

Tą operację można przeprowadzić również w jednej linii kodu używając argumentu
`mask = TRUE` w funkcji `crop()`.

```{r eval=FALSE}
crop(landsat, poly, mask = TRUE)
```

W następnym kroku możemy w prosty sposób sprawdzić statystyki opisowe naszego
zbioru danych.

```{r}
summary(landast)
```

Jak możemy zauważyć wartości odbicia spektralnego dla naszego zbioru danych są
w zakresie od kilku do kilkunastu tysięcy dla każdego kanału. Z definicji odbicie
spektralne jest w przedziale od 0 do 1. Takie dane musimy przeskalować za pomocą
poniższego róWnania:

$$x = x \cdot 0.0000275 - 0.2$$

Nie ma potrzeby stosowania tego wzoru osobno dla każdego kanału, ponieważ
domyślnie operacje matematyczne są stosowane dla wszystkich kanałów.

```{r}
landsat = landsat * 2.75e-05 - 0.2
summary(landsat)
```

Nadal możemy zauważyć, że pewne wartości przekraczają nasz zakres od 0 do 1.
Są to wartości odstające, które zazwyczaj związane są z błędnym pomiarem lub
nadmierną saturacją. Można ten problem rozwiązać na dwa sposoby:
1. Zastąpić te wartości brakiem danych (NA).
2. Dociąć do miminalnej i maksymalnej wartości.
Pierwszy sposób może spowodować, że stracimy dużą część zbioru danych.
Natomiast drugi sposób może powodować przekłamania.

```{r}
# sposob nr 1
landsat[landsat < 0] = NA
landsat[landsat > 1] = NA
```

```{r eval=FALSE}
# sposob nr 2
landsat[landsat < 0] = 0
landsat[landsat > 1] = 1
```

Po przeskalowaniu wartości możemy wyświetlić kompozycję RGB. W tym przypadku
zamiast funkcji `plot()` należy użyć funkcji `plotRGB()` oraz zdefiniować 
kolejność kanałóW czerwonego, zielonego oraz niebieskiego. Oprócz tego,
należy podać maksymalną wartość odbicia dla kanałów (w naszym przypadku `scale = 1`).
Często zdarza się, że kompozycje są zbyt ciemne/jasne, wtedy warto zastosować
rozciągnięcie histogramów używając argumentu `stretch = "lin"` lub
`stretch = "hist"`.

```{r}
plotRGB(landsat, r = 4, g = 3, b = 2, scale = 1, stretch = "lin")
```

## Klasteryzacja

```{r}
# wczytanie pakietu do klasteryzacji
library("cluster")
```

Modele do klasteryzacji (oraz klasyfikacji nadzorowanej) wymagają macierzy 
lub ramki danych. Zatem dane do treningu musimy przygotować w odpowiedni sposób.
Raster można sprowadzić do macierzy przy użyciu funkcji `values()`.

```{r}
mat = values(landsat)
nrow(mat) # wyświetla liczbę wierszy
```

Za pomocą funkcji `View()` możemy sprawdzić jak wygląda nasza macierz.
Jak łatwo można zauważyć, mnóstwo jej wartości oznaczonych jest jako brak danych
(głównie są to wartości poza obszarem analizy). Zazwyczaj modele nie obsługują
NA, więc musimy je usunąć. Służy do tego dedykowana funkcja `na.omit()`.

```{r}
mat_omit = na.omit(mat)
nrow(mat_omit)
```

Teraz przejdziemy do najważniejszego etapu analizy, czyli do wytrenowania modelu.
Użyjemy najprostszego modelu [grupowania k-średnich](https://www.statsoft.pl/textbook/stcluan.html#k) (*k-means*).
Ten model wymaga jedynie, aby podać z góry liczę klastrów (grup).
Jest to algorytm stochastyczny, więc za każdym razem zwraca inne wyniki.
Żeby analiza była powtarzalna musimy ustawić ziarno losowości - `set.seed()`.

```{r}
set.seed(123)
mdl = kmeans(mat_omit, centers = 5)
mdl$centers # obliczone średnie wartości klastrów
```

W wyniku powyższej operacji otrzymaliśmy m. in.:
1. Obliczone średnie wartości klastrów dla poszczególnych kanałóW (`mdl$centers`).
2. Wektor ze sklasyfikowanymi wartościami macierzy (`mdl$cluster`).

Wyświetlmy te obiekty:

```{r}
mdl$centers
```

```{r}
head(mdl$cluster) # wyświetla pierwsze 6 elementów
```

Oznacza to, że pierwszy wiersz (piksel) należy do grupy 3, drugi do grupy 2,
trzecu do grupy 2, itd. Kolejnym etapem jest stworzenie mapy na podstawie
otrzymanego wektora z klastrami.

Na początku musimy przygotować pusty wektor składający się z całkowitej liczby
pikseli rastra. Można to sprawdzić za pomocą funkcji `ncell()`. W naszym
przypadku jest to 1 238 760. ........


```{r}

# prepare vector with clusters
vec = rep(NA, ncell(landsat))
vec[complete.cases(mat)] = mdl$cluster # only replace values that aren't NA

# create raster with clusters
clustering = rast(landsat, nlyrs = 1)
values(clustering) = vec

colors = c("#fdd327", "#d9d9d9", "#1445f9", "#91632b", "#086209")
category = c("pola uprawne", "odkryta gleba", "woda", "zabudowa", "lasy")
plot(clustering, col = colors, type = "classes", levels = category)

# write
writeRaster(clustering, "clustering.tif")
```

```{r}
library("tidyr")
library("ggplot2")

idx = sample(1:nrow(mat_omit), 10000)
stats = cbind(mat_omit, cluster = mdl$cluster)
stats = as.data.frame(stats)
stats = pivot_longer(stats, 1:7, names_to = "band", values_to = "value")
stats$cluster = as.factor(stats$cluster)
stats$band = as.factor(stats$band)

ggplot(stats, aes(x = band, y = value, color = cluster)) +
  geom_boxplot(show.legend = FALSE) +
  scale_colour_manual(values = colors) +
  facet_wrap(vars(cluster)) +
  xlab("Band") +
  ylab("Reflectance") +
  theme_light()

ggplot(stats, aes(x = cluster, y = value, color = cluster)) +
  geom_boxplot(show.legend = FALSE) +
  scale_colour_manual(values = colors) +
  facet_wrap(vars(band)) +
  xlab("Cluster") +
  ylab("Reflectance") +
  theme_light()
```


